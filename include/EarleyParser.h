/*
 * NLP_Earley_Parser_main.cpp
 * EarleyParser.h
 * EarleyParser.cpp
 * Node.h
 * Node.cpp
 * State.h
 * State.cpp
 * Production.h
 * Production.cpp
 *
 *  Created on: Oct 17, 2012
 *      Author: Matteo Ruggero Ronchi
 *
 *  Copyright 2012 Matteo Ruggero Ronchi
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/*
 * Like any free software license, the Apache License allows the user of the software 
 * the freedom to use the software for any purpose, to distribute it, to modify it, 
 * and to distribute modified versions of the software, under the terms of the license.
 *
 * The Apache License, does not require modified versions of the software
 * to be distributed using the same license (in contrast to copyleft licenses).
 *
 * In every licensed file, any original copyright, patent, trademark, 
 * and attribution notices in redistributed code must be preserved
 * (excluding notices that do not pertain to any part of the derivative works), 
 * and, in every licensed file changed, a notification must be added stating that changes have been made to that file.
 *
 * If a NOTICE text file is included as part of the distribution of the original work, 
 * then derivative works must include a readable copy of these notices in at least one of three places: 
 * - within a NOTICE text file distributed as part of the derivative works
 * - within the source form or documentation
 * - within a display generated by the derivative works (wherever such third-party notices normally appear). 
 *
 * The contents of the NOTICE file do not modify the license, as they are for informational purposes only. 
 * Modifications may have appropriate copyright notices, and may provide different license terms for the modifications.
 *
 */

/*
 * NLP Earley Parser is a C++ class for parsing an input string with respect to a specified
 * context free grammar provided as input, and obtaining all parsing trees associated with the 
 * corresponding probability.
 * 
 * Feel free to contact me for any kind of explanation request, suggestion, or bug individuation:
 * 
 * - email address: matrronchi.license@gmail.com 
 * - skype account: matteorr
 *
 */


/*
 * The file is an accumulation of the files named at the top. It has been extensively modified to
 * work with this projects grammar structure. It removes i/o functions etc.
 * Additionally recursive functions such as Node::~Node and Node::expandNode have been rewritten
 * to work iteratively due to significant stackoverflows in the original functions.
 */
	







#include "Grammar.h"
#include "DerivationTree.h"
#include "Logging.h"

#include <string>
#include <unordered_map>
#include <stack>


class State
{
public:
	State(Types::shared_ptr<GrammarNode> _nonterminal, Types::shared_ptr<GrammarExpansion> productionPointer, State* backtraceState, int64_t inputStringProgress, int64_t productionProgress)
	{
		this->nonTerminal = _nonterminal;
		this->productionPointer = productionPointer;

		this->backtraceStateVector.push_back(backtraceState);

		this->inputStringProgress = inputStringProgress;
		this->productionProgress = productionProgress;
	}

	//State();

	virtual ~State()
	{

	}

	std::vector<State*>* getBacktraceStateVector()
	{
		return &(this->backtraceStateVector);
	}
	const Types::shared_ptr<GrammarNode> getNonTerminal()
	{
		return this->nonTerminal;
	}

	Types::shared_ptr<GrammarExpansion> getProductionPointer()
	{
		return this->productionPointer;
	}
	int64_t getProductionProgress()
	{
		return this->productionProgress;
	}
	int64_t getInputStringProgress()
	{
		return this->inputStringProgress;
	}

	bool isComplete()
	{
		if (this->getProductionProgress() == (nonTerminal->IsSequence() ? 0 : (int64_t)this->getProductionPointer()->_nodes.size()))
			return true;
		else
			return false;
	}
	Types::shared_ptr<GrammarNode> nextSymbolToProcess()
	{
		return this->getProductionPointer()->_nodes.at(this->productionProgress);
	}

	bool getPrinted()
	{
		return this->printed;
	}
	void setPrintedTrue()
	{
		this->printed = true;
	}

private:
	explicit State() :
		productionPointer(NULL) {}

	Types::shared_ptr<GrammarNode> nonTerminal;
	Types::shared_ptr<GrammarExpansion> productionPointer;

	std::vector<State*> backtraceStateVector;

	int64_t productionProgress;
	int64_t inputStringProgress;

	bool printed;
};


class Node
{
public:
	Node(Node* father, Types::shared_ptr<GrammarNode> grammarElement, Types::shared_ptr<GrammarExpansion> productionPointer, float productionProbability)
	{
		this->father = father;

		this->grammarElement = grammarElement;
		this->productionProbability = productionProbability;

		this->productionPointer = productionPointer;
	}

	virtual ~Node()
	{
		std::stack<Node*> stack;
		for (std::vector<Node*>::iterator it = this->children.begin(); it != this->children.end(); it++) {
			stack.push(*it);
		}
		Node* tmp = nullptr;
		while (stack.size() > 0)
		{
			tmp = stack.top();
			stack.pop();

			for (auto itr = tmp->children.begin(); itr != tmp->children.end(); itr++) {
				stack.push(*itr);
			}
			tmp->children.clear();
			delete tmp;
		}
	}

	State* expandNode(State* stateToExpand)
	{
		// contains the next statetoexpand for the next item
		std::stack<State*> resultstack;
		// node, state, reverse order, child to handle
		std::stack<std::tuple<Node*, State*, bool, int64_t>> stack;
		stack.push({ this, stateToExpand, false, -1 });

		while (stack.size() > 0) {
			auto [self, currentStateToExpand, reverse, chnum] = stack.top();
			stack.pop();

			State* nextStateToExpand = nullptr;

			if (resultstack.size() > 0) {
				currentStateToExpand = resultstack.top();
				resultstack.pop();
			}

			if (reverse) {
				resultstack.push(currentStateToExpand);
				continue;
			}

			// if we are not on the reverse track
			// we add ourselves for reversing onto the stack
			// begin with ourselves
			stack.push({ self, currentStateToExpand, true, -1 });

			if (!reverse && chnum == -1) {
				for (int64_t i = 0; i < (int64_t)self->productionPointer->_nodes.size(); i++) {
					stack.push({ self, currentStateToExpand, false, i });
				}
				continue;
			}

			Types::shared_ptr<GrammarNode> got = self->productionPointer->_nodes.at(chnum);
			if (got->IsSequence() == false) {
				/*
					* the element contained in the production
					* at current position of loop is NON TERMINAL
					* and needs to be expanded
					*/
				if (currentStateToExpand->getBacktraceStateVector()->size() > 1) {
					for (int64_t j = 0; j < (int64_t)currentStateToExpand->getBacktraceStateVector()->size(); j++) {
						if (self->father->getProductionPointer() == currentStateToExpand->getBacktraceStateVector()->at(j)->getProductionPointer()) {
							nextStateToExpand = currentStateToExpand->getBacktraceStateVector()->at(j);
							//	cout << "[DEBUG]: matching production pointer at position " << j << endl;
							break;
						}

						if (j == (int64_t)currentStateToExpand->getBacktraceStateVector()->size() - 1) {
							logcritical("[ERROR]: no matching production pointer correspondent to production in this node!");
							exit(1);
						}
					}

				} else {
					nextStateToExpand = currentStateToExpand->getBacktraceStateVector()->at(0);
				}

				Node* child;
				if (self->productionProbability >= 0) {
					child = new Node(
						self,
						nextStateToExpand->getNonTerminal(),
						nextStateToExpand->getProductionPointer(),
						nextStateToExpand->getProductionPointer()->_weight);
				} else {
					child = new Node(
						self,
						nextStateToExpand->getNonTerminal(),
						nextStateToExpand->getProductionPointer(),
						-1);
				}

				/*
					* insert at beginning of vector
					*/
				self->children.insert(self->children.begin(), child);

				// stack operation ended so push next one onto stack and continue
				stack.push({ child, nextStateToExpand, false, -1 });

			} else {
				/*
					* the element is TERMINAL
					* and needs not to be exapanded
					*/

				Node* child;
				if (self->productionProbability >= 0) {
					child = new Node(
						self,
						self->productionPointer->_nodes.at(chnum),
						Types::make_shared<GrammarExpansion>(),
						1);
				} else {
					child = new Node(
						self,
						self->productionPointer->_nodes.at(chnum),
						Types::make_shared<GrammarExpansion>(),
						-1);
				}

				self->children.insert(self->children.begin(), child);

				if (currentStateToExpand->getBacktraceStateVector()->size() > 1) {
					for (int64_t j = 0; j < (int64_t)currentStateToExpand->getBacktraceStateVector()->size(); j++) {
						State* state = currentStateToExpand->getBacktraceStateVector()->at(j);
					}

					for (int64_t j = 0; j < (int64_t)currentStateToExpand->getBacktraceStateVector()->size(); j++) {
						if (self->father->getProductionPointer() == currentStateToExpand->getBacktraceStateVector()->at(j)->getProductionPointer()) {
							currentStateToExpand = currentStateToExpand->getBacktraceStateVector()->at(j);
							//cout << "[DEBUG]: matching production pointer at position " << j << endl;
							break;
						}

						if (j == (int64_t)currentStateToExpand->getBacktraceStateVector()->size() - 1) {
							logcritical("[ERROR]: no matching production pointer correspondent to production in this node!");
							return nullptr;
						}
					}

				} else {
					currentStateToExpand = currentStateToExpand->getBacktraceStateVector()->at(0);
				}

				if (currentStateToExpand->getBacktraceStateVector()->size() > 1) {
					for (unsigned j = 0; j < currentStateToExpand->getBacktraceStateVector()->size(); j++) {
						State* state = currentStateToExpand->getBacktraceStateVector()->at(j);
					}

					//for( unsigned j = currentStateToExpand->getBacktraceStateVector()->size() - 1; j >= 0; j-- )
					for (int64_t j = 0; j < (int64_t)currentStateToExpand->getBacktraceStateVector()->size(); j++) {
						if (self->father->getProductionPointer() == currentStateToExpand->getBacktraceStateVector()->at(j)->getProductionPointer()) {
							currentStateToExpand = currentStateToExpand->getBacktraceStateVector()->at(j);
							break;
						} else {
						}

						if (j == (int64_t)currentStateToExpand->getBacktraceStateVector()->size() - 1 /*0*/) {
							logcritical("[ERROR]: no matching production pointer correspondent to production in this node!");
							return nullptr;
						}
					}

				} else {
					currentStateToExpand = currentStateToExpand->getBacktraceStateVector()->at(0);
				}

				// we have a new currentStateToExpand that we need to give back to the upper node
				resultstack.push(currentStateToExpand);
			}
		}
		if (resultstack.size() > 0)
			return resultstack.top();
		return stateToExpand;
	}

	float print(bool printProbabilities)
	{
		float prob = -1;

		//cout << "Node [" << this->grammarElement << "]{";

		if (printProbabilities == true) {
			if (this->children.size() == 0) {
				/*
			 * we are in a leaf node
			 */
				prob = this->productionProbability;

			} else {
				prob = this->productionProbability;
				for (std::vector<Node*>::iterator it = this->children.begin(); it != this->children.end(); it++) {
					prob = prob * (*it)->print(printProbabilities);
				}
			}
		} else {
			for (std::vector<Node*>::iterator it = this->children.begin(); it != this->children.end(); it++) {
				prob = (*it)->print(printProbabilities);
			}
		}
		//cout << "prob [" << prob << "]}";

		return prob;
	}

	Types::shared_ptr<GrammarExpansion> getProductionPointer()
	{
		return this->productionPointer;
	}

	std::vector<Node*> getChildren()
	{
		return children;
	}
	Types::shared_ptr<GrammarNode> getGrammarElement()
	{
		return grammarElement;
	}


private:
	explicit Node() {}

	Types::shared_ptr<GrammarNode> grammarElement;
	Node* father;

	std::vector<Node*> children;

	float productionProbability;

	Types::shared_ptr<GrammarExpansion> productionPointer;
};


class EarleyParser
{
public:
	std::vector<std::vector<State*>> earleyParserChart;
	std::vector<Types::shared_ptr<GrammarNode>> inputVector;
	bool probabilityParser;

	std::vector<Node*> returnVector;

	std::vector<Types::shared_ptr<GrammarExpansion>> lonely = { Types::make_shared<GrammarExpansion>() };


	EarleyParser()
	{
		lonely[0]->_nodes.push_back(Types::make_shared<GrammarNode>());
		lonely[0]->_nodes[0]->_type = GrammarNode::NodeType::Terminal;
	}
	~EarleyParser()
	{
		for (int64_t i = 0; i <= (int64_t)this->inputVector.size(); i++) {
			for (std::vector<State*>::iterator it = this->earleyParserChart.at(i).begin(); it != this->earleyParserChart.at(i).end(); it++) {
				delete *it;
			}
		}

		for (std::vector<Node*>::iterator it = this->returnVector.begin(); it != this->returnVector.end(); it++) {
			delete *(it);
		}
	}

	void initialize(bool a_probabilityParser)
	{
		this->probabilityParser = a_probabilityParser;
	}

	/// <summary>
	/// returns the parent of a grammar node as those are basically their productions
	/// </summary>
	/// <param name=""></param>
	/// <returns></returns>
	std::vector<Types::shared_ptr<GrammarExpansion>> getProduction(Types::shared_ptr<GrammarNode> node)
	{ 
		return node->IsSequence() ? std::vector<Types::shared_ptr<GrammarExpansion>>{} : node->_expansions;
	}
	int64_t createChart(Types::shared_ptr<GrammarNode> root)
	{
		earleyParserChart.resize(inputVector.size() + 1);
		auto expansions = getProduction(root);
		for (auto expansion : expansions)
		{
			State* initialState = new State(root, expansion, NULL, 0, 0);
			earleyParserChart[0].push_back(initialState);
		}
		size_t sz = inputVector.size();
		for (size_t i = 0; i < sz; i++)
			earleyParserChart[i].reserve(sz + 1);
		return 1;
	}
	void parse()
	{
		for (int64_t i = 0; i <= (int64_t)inputVector.size(); i++)
		{
			//StartProfiling
			//std::cout << i << "\n";
			for (int64_t j = 0; j < (int64_t)earleyParserChart[i].size(); j++)
			{
				if (!(earleyParserChart[i].at(j)->isComplete())) {
					/*
					* the state is not complete
					* the production corresponding to the state has not
					* been yet analized completely
					*/
					if (this->getProduction(earleyParserChart[i].at(j)->nextSymbolToProcess()).size() != 0)
					{
						predictor(earleyParserChart[i].at(j), i);
					} else
						scanner(earleyParserChart[i].at(j), i);
				}
				else
				{
					completer(earleyParserChart[i].at(j), i);
				}
			}
			//profile(TimeProfiling, "");
		}
	}

	std::vector<Node*>* returnParsingTrees(Types::shared_ptr<GrammarNode> mainNonTerminal)
	{
		for (std::vector<State*>::iterator it = this->earleyParserChart[this->inputVector.size()].begin();
			 it != this->earleyParserChart[this->inputVector.size()].end(); it++) {
			if ((*it)->getNonTerminal() == mainNonTerminal && (*it)->getProductionProgress() == (int64_t)(*it)->getProductionPointer()->_nodes.size()) {
				State* stateBookmark = (*it);
				Node* rootOfParsingTree;

				if (this->probabilityParser == true) {
					rootOfParsingTree =
						new Node(
							NULL,
							stateBookmark->getNonTerminal(),
							stateBookmark->getProductionPointer(),
							stateBookmark->getProductionPointer()->_weight);
				} else {
					rootOfParsingTree =
						new Node(
							NULL,
							stateBookmark->getNonTerminal(),
							stateBookmark->getProductionPointer(),
							-1);
				}

				//std::vector<State*>* test;
				State* test2;
				test2 = rootOfParsingTree->expandNode(stateBookmark);

				this->returnVector.push_back(rootOfParsingTree);
			}
		}

		return &this->returnVector;
	}

	void predictor(State* stateToExpand, int64_t positionInputString)
	{
		Types::shared_ptr<GrammarExpansion> productionInStateToExpand = stateToExpand->getProductionPointer();
		if (stateToExpand->getProductionProgress() >= (int64_t)productionInStateToExpand->_nodes.size()) {
			logcritical("[ERROR]: overflow in predictor!");
			return;
		}
		Types::shared_ptr<GrammarNode> nonTerminalToExpand = productionInStateToExpand->_nodes.at(stateToExpand->getProductionProgress());

		auto listProductions = getProduction(nonTerminalToExpand);

		for (int64_t i = 0; i < (int64_t)listProductions.size(); i++)
		{
			State* stateToInsert = new State(nonTerminalToExpand, listProductions[i], stateToExpand, positionInputString, 0);

			int64_t positionOfState = stateExists(positionInputString, stateToInsert);
			if (positionOfState < 0)
			{
				/*
				 * state not already in the chart
				 */

				this->earleyParserChart[positionInputString].push_back(stateToInsert);
			} else {
				/*
				 * state already in chart
				 * pushes back the state from which it comes inside it's backtrace state vector
				 */
				this->earleyParserChart[positionInputString].at(positionOfState)->getBacktraceStateVector()->push_back(stateToExpand);
				delete stateToInsert;
			}
		}
	}
	void scanner(State* stateToScan, int64_t positionInputString)
	{
		Types::shared_ptr<GrammarExpansion> productionInStateToScan = stateToScan->getProductionPointer();
		if (positionInputString >= (int64_t)inputVector.size())
		{
			//logcritical("[DEBUG]: scanner fail, input string end reached");
			return;
		}
		if (inputVector.at(positionInputString) == productionInStateToScan->_nodes.at(stateToScan->getProductionProgress()))
		{
			/*
			* the symbol to be scanned in the production is the same of the input string
			* a new state must be created in the next position of the chart
			*
			* must check for equal states in the chart and avoid insertion in case
			*/

			State* stateToInsert = new State(stateToScan->getNonTerminal(), stateToScan->getProductionPointer(), stateToScan, stateToScan->getInputStringProgress(), stateToScan->getProductionProgress() + 1);
			//cout << "[DEBUG]: scanner is inserting state in chart position " << positionInputString + 1 << endl;
			this->earleyParserChart[positionInputString + 1].push_back(stateToInsert);
		} else {
			/*
			* do nothing
			* symbol to be scanned does not match with symbol in the input string
			*/
		}
	}
	void completer(State* stateCompleted, int64_t positionInputString)
	{
		if (stateCompleted->getInputStringProgress() >= (int64_t)this->earleyParserChart.size()) {
			logcritical("[ERROR] : COMPLETER OVERFLOW");
			return;
		}
		for (std::vector<State*>::iterator it = this->earleyParserChart[stateCompleted->getInputStringProgress()].begin();
			 it != this->earleyParserChart[stateCompleted->getInputStringProgress()].end(); it++) {
			if ((int64_t)(*it)->getProductionPointer()->_nodes.size() <= (*it)->getProductionProgress())
				continue;
			if (stateCompleted->getNonTerminal() == (*it)->getProductionPointer()->_nodes.at((*it)->getProductionProgress())) {
				//cout << "before constructor in complete" << endl;
				State* stateToInsert = new State((*it)->getNonTerminal(), (*it)->getProductionPointer(), stateCompleted, (*it)->getInputStringProgress(), (*it)->getProductionProgress() + 1);
				this->earleyParserChart[positionInputString].push_back(stateToInsert);
				//cout << "after push back in complete" << endl;
			}
			//cout << "destructor called in complete" << endl;
		}
	}

	int64_t stateExists(int64_t chartPosition, State* stateToCheck)
	{
		for (std::vector<State*>::iterator it = this->earleyParserChart[chartPosition].begin(); it != this->earleyParserChart[chartPosition].end(); it++) {
			if ((*it)->getNonTerminal() == stateToCheck->getNonTerminal() &&
				(*it)->getInputStringProgress() == stateToCheck->getInputStringProgress() &&
				(*it)->getProductionPointer() == stateToCheck->getProductionPointer() &&
				(*it)->getProductionProgress() == stateToCheck->getProductionProgress()) {
				//cout << "[DEBUG]: found same state at position " << it - this->earleyParserChart[chartPosition].begin() << " of chart[" << chartPosition << "]" << endl;
				return (it - this->earleyParserChart[chartPosition].begin());
			}
		}
		return -1;
	}
};

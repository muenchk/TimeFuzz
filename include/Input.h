#pragma once

#include <list>
#include <filesystem>
#include <chrono>
#include <lua.hpp>

#include "DerivationTree.h"
#include "TaskController.h"
#include "Utility.h"
#include "Form.h"

class ExecutionHandler;
class Test;
class SessionFunctions;

struct lua_State;

class Input : public Form
{
	friend class SessionFunctions;

	const int32_t classversion = 0x1;
	#pragma region InheritedForm
public:
	size_t GetStaticSize(int32_t version = 0x1) override;
	size_t GetDynamicSize() override;
	bool WriteData(unsigned char* buffer, size_t& offset) override;
	bool ReadData(unsigned char* buffer, size_t& offset, size_t length, LoadResolver* resolver) override;
	int32_t GetType() override {
		return FormType::Input;
	}
	static int32_t GetTypeStatic()
	{
		return FormType::Input;
	}
	void Delete(Data* data);
	void Clear() override;
	inline static bool _registeredFactories = false;
	static void RegisterFactories();

	#pragma endregion

private:
	struct ParentInformation
	{
		FormID parentInput = 0;
		int64_t positionBegin = 0;
		int64_t length = 0;
		bool complement = false;
	};

	/// <summary>
	/// whether the input has been tested and has finished
	/// </summary>
	bool _hasfinished = false;
	/// <summary>
	/// whether the input has been trimmed
	/// </summary>
	bool _trimmed = false;
	/// <summary>
	/// the length to which the input has been trimmed
	/// </summary>
	int64_t _trimmedlength = -1;
	/// <summary>
	/// the execution time of the associated test
	/// </summary>
	std::chrono::nanoseconds _executiontime = std::chrono::nanoseconds(0);
	/// <summary>
	/// the exit code of the associated test
	/// </summary>
	int32_t _exitcode = 0;
	/// <summary>
	/// the primary score of the input
	/// </summary>
	double _primaryScore = 0.f;
	/// <summary>
	/// the secondary score of the input
	/// </summary>
	double _secondaryScore = 0.f;

	friend ExecutionHandler;
	friend Test;

	/// <summary>
	/// the python representation of the input
	/// </summary>
	std::string _pythonstring = "";
	/// <summary>
	/// whether the python representation has been calculated
	/// </summary>
	bool _pythonconverted = false;

	/// <summary>
	/// whether the sequence has been generated
	/// </summary>
	bool _generatedSequence = false;

	/// <summary>
	/// information about the parent Input
	/// </summary>
	ParentInformation _parent;

	/// <summary>
	/// The ID of the generation this input belongs to
	/// </summary>
	FormID _generationID = 0;

	/// <summary>
	/// number of inputs that have been derived from this input
	/// </summary>
	uint64_t _derivedInputs = 0;

	/// <summary>
	/// runtime at which this input was generated
	/// </summary>
	std::chrono::nanoseconds _generationTime = std::chrono::nanoseconds(0);

public:
	struct Flags
	{
		enum Flag : EnumType
		{
			/// <summary>
			/// No flags
			/// </summary>
			None = 0 << 0,
			/// <summary>
			/// This input cannot be derived from a derivation tree
			/// </summary>
			//NoDerivation = 1 << 0,
			/// <summary>
			/// Do not free memory allocated by this instance
			/// </summary>
			//DoNotFree = 1 << 1,
			/// <summary>
			/// The input is a duplicate of an already existing input and can be discarded
			/// </summary>
			Duplicate = 1 << 2,
			/// <summary>
			/// Input has already been deta debugged
			/// </summary>
			DeltaDebugged = 1 << 3,
			/// <summary>
			/// Input has been generated from a grammatic
			/// </summary>
			GeneratedGrammar = 1 << 4,
			/// <summary>
			/// Input has been generated as an extension of an existing input
			/// </summary>
			GeneratedGrammarParent = 1 << 5,
			/// <summary>
			/// Input has been generated by backtracking on an existing input instead of extension
			/// </summary>
			GeneratedGrammarParentBacktrack = 1 << 6,
			/// <summary>
			/// Input has been created as a result of splitting another input
			/// </summary>
			GeneratedDeltaDebugging = 1 << 7,
		};
	};

	std::shared_ptr<Test> test;
	Input();

	~Input();

	static int lua_ConvertToPython(lua_State* L);
	static int lua_IsTrimmed(lua_State* L);
	static int lua_TrimInput(lua_State* L);
	static int lua_GetExecutionTime(lua_State* L);
	static int lua_GetExitCode(lua_State* L);
	static int lua_GetSequenceLength(lua_State* L);
	static int lua_GetSequenceFirst(lua_State* L);
	static int lua_GetSequenceNext(lua_State* L);
	static int lua_GetExitReason(lua_State* L);
	static int lua_GetCmdArgs(lua_State* L);
	static int lua_GetOutput(lua_State* L);
	static int lua_GetReactionTimeLength(lua_State* L);
	static int lua_GetReactionTimeFirst(lua_State* L);
	static int lua_GetReactionTimeNext(lua_State* L);
	static int lua_SetPrimaryScore(lua_State* L);
	static int lua_SetSecondaryScore(lua_State* L);

	static void RegisterLuaFunctions(lua_State* L);

	/// <summary>
	/// converts the input to python code
	/// </summary>
	std::string ConvertToPython(bool update = false);
	/// <summary>
	/// converts the input to a stream
	/// </summary>
	void ConvertToStream();
	/// <summary>
	/// returns the number of entries in the input
	/// </summary>
	/// <returns></returns>
	size_t Length();
	/// <summary>
	/// returns the current length of the sequeÂ´nce
	/// </summary>
	/// <returns></returns>
	size_t GetSequenceLength();
	/// <summary>
	/// converts the input to a string
	/// </summary>
	/// <param name="index"></param>
	/// <returns></returns>
	std::string& operator[](size_t index);
	/// <summary>
	/// Adds an entry at the end of the input
	/// </summary>
	/// <param name="entry"></param>
	void AddEntry(std::string entry);
	/// <summary>
	/// Marks the input as containing a valid input sequence
	/// </summary>
	void SetGenerated(bool generated = true) { _generatedSequence = generated; }
	/// <summary>
	/// Returns whether the input sequence has been generated
	/// </summary>
	/// <returns></returns>
	bool GetGenerated() { return _generatedSequence; }
	/// <summary>
	/// converts the input to a string
	/// </summary>
	/// <returns></returns>
	std::string ToString();
	/// <summary>
	/// returns the hash of the input
	/// </summary>
	/// <returns></returns>
	std::size_t Hash();
	/// <summary>
	/// iterator pointing to the first element of the input
	/// </summary>
	/// <returns></returns>
	[[nodiscard]] std::list<std::string>::iterator begin();
	/// <summary>
	/// iterator pointing beyond the last element of the input
	/// </summary>
	/// <returns></returns>
	[[nodiscard]] std::list<std::string>::iterator end();

	/// <summary>
	/// Returns the execution time of the test if it has already finished, otherwise -1
	/// </summary>
	/// <returns></returns>
	inline std::chrono::nanoseconds GetExecutionTime()
	{
		if (_hasfinished)
			return _executiontime;
		else
			return std::chrono::nanoseconds(-1);
	}

	/// <summary>
	/// Returns the exitcode of the test if it has already finished, otherwise -1
	/// </summary>
	/// <returns></returns>
	inline int32_t GetExitCode()
	{
		if (_hasfinished)
			return _exitcode;
		else
			return -1;
	}

	/// <summary>
	/// Returns whether the corresponding test has finished
	/// </summary>
	/// <returns></returns>
	inline bool Finished()
	{
		return _hasfinished;
	}

	/// <summary>
	/// Returns the oracle result
	/// </summary>
	/// <returns></returns>
	inline EnumType GetOracleResult()
	{
		return _oracleResult;
	}

	inline double GetPrimaryScore()
	{
		return _primaryScore;
	}

	inline double GetSecondaryScore()
	{
		return _secondaryScore;
	}

	void TrimInput(int32_t executed);

	int64_t GetTrimmedLength() { return _trimmedlength; }

	bool IsTrimmed() { return _trimmed; }

	/// <summary>
	/// Parses inputs from a python file.
	/// [The file should contain a variable name [inputs = ...]
	/// </summary>
	/// <param name="path"></param>
	/// <returns></returns>
	static std::vector<std::shared_ptr<Input>> ParseInputs(std::filesystem::path path);

	/// <summary>
	/// derivation/parse tree of the input
	/// </summary>
	std::shared_ptr<DerivationTree> derive;

	/// <summary>
	/// copies all internal values except [Test] and [DerivationTree] to [other]
	/// </summary>
	/// <param name="other"></param>
	void DeepCopy(std::shared_ptr<Input> other);

	/// <summary>
	/// Attempts to release as much memory as possible
	/// </summary>
	void FreeMemory() override;

	/// <summary>
	/// Sets the input as generated as split of a parent input, also sets corresponding flags
	/// </summary>
	/// <param name="parentInput"></param>
	/// <param name="positionBegin"></param>
	/// <param name="length"></param>
	void SetParentSplitInformation(FormID parentInput, int64_t positionBegin, int64_t length, bool complement);
	/// <summary>
	/// Sets the input as generated extension from a parent input, also sets corresponding flags
	/// </summary>
	/// <param name="parentInput"></param>
	void SetParentGenerationInformation(FormID parentInput);
	/// <summary>
	/// Sets the input as generated from a grammatic
	/// </summary>
	/// <param name="parentInput"></param>
	void SetGenerationInformation();
	/// <summary>
	/// returns the formid of the parent input
	/// </summary>
	/// <returns></returns>
	FormID GetParentID();
	/// <summary>
	/// Returns the begin of this sequence in the sequence of the parent Input
	/// </summary>
	/// <returns></returns>
	int64_t GetParentSplitBegin();
	/// <summary>
	/// Returns the length of this sequence as a subset of the parent Input
	/// </summary>
	/// <returns></returns>
	int64_t GetParentSplitLength();
	/// <summary>
	/// Returns wether the ParentSplitBegin and ParentSplitLength values are of the complement of this sequence
	/// </summary>
	/// <returns></returns>
	bool GetParentSplitComplement();

	/// <summary>
	/// Returns the ID of the generation this input belongs to
	/// </summary>
	/// <returns></returns>
	FormID GetGenerationID();
	/// <summary>
	/// Sets the generation this input belongs to
	/// </summary>
	/// <param name="genID"></param>
	void SetGenerationID(FormID genID);

	/// <summary>
	/// Increments the number of inputs derived from this one
	/// </summary>
	void IncDerivedInputs()
	{
		std::unique_lock<std::shared_mutex> guard(_lock);
		_derivedInputs++;
	}
	/// <summary>
	/// Returns the number of inputs derived from this one
	/// </summary>
	uint64_t GetDerivedInputs() {
		std::shared_lock<std::shared_mutex> guard(_lock);
		return _derivedInputs;
	}

	/// <summary>
	/// Sets the runtime at which this input was generated
	/// </summary>
	/// <param name="genTime"></param>
	void SetGenerationTime(std::chrono::nanoseconds genTime)
	{
		std::unique_lock<std::shared_mutex> guard(_lock);
		_generationTime = genTime;
	}

private:
	/// <summary>
	/// the string representation of the input
	/// </summary>
	std::string _stringrep = "";
	/// <summary>
	/// the oracle result of the input
	/// </summary>
	EnumType _oracleResult;
	/// <summary>
	/// the underlying representation of the input sequence
	/// </summary>
	std::list<std::string> _sequence;

	std::list<std::string>::iterator _lua_sequence_next;

	/// <summary>
	/// originally generated sequence [stores sequence after trimming]
	/// </summary>
	std::list<std::string> _orig_sequence;

	bool ReadData0x1(unsigned char* buffer, size_t& offset, size_t length, LoadResolver* resolver);
	bool ReadData0x2(unsigned char* buffer, size_t& offset, size_t length, LoadResolver* resolver);
};
